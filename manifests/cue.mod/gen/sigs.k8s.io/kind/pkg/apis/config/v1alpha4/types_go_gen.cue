// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go sigs.k8s.io/kind/pkg/apis/config/v1alpha4

package v1alpha4

// Cluster contains kind cluster configuration
#Cluster: {
	#TypeMeta

	// The cluster name.
	// Optional, this will be overridden by --name / KIND_CLUSTER_NAME
	name?: string @go(Name)

	// Nodes contains the list of nodes defined in the `kind` Cluster
	// If unset this will default to a single control-plane node
	// Note that if more than one control plane is specified, an external
	// control plane load balancer will be provisioned implicitly
	nodes?: [...#Node] @go(Nodes,[]Node)

	// Networking contains cluster wide network settings
	networking?: #Networking @go(Networking)

	// FeatureGates contains a map of Kubernetes feature gates to whether they
	// are enabled. The feature gates specified here are passed to all Kubernetes components as flags or in config.
	//
	// https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/
	featureGates?: {[string]: bool} @go(FeatureGates,map[string]bool)

	// RuntimeConfig Keys and values are translated into --runtime-config values for kube-apiserver, separated by commas.
	//
	// Use this to enable alpha APIs.
	runtimeConfig?: {[string]: string} @go(RuntimeConfig,map[string]string)

	// KubeadmConfigPatches are applied to the generated kubeadm config as
	// merge patches. The `kind` field must match the target object, and
	// if `apiVersion` is specified it will only be applied to matching objects.
	//
	// This should be an inline yaml blob-string
	//
	// https://tools.ietf.org/html/rfc7386
	//
	// The cluster-level patches are appied before the node-level patches.
	kubeadmConfigPatches?: [...string] @go(KubeadmConfigPatches,[]string)

	// KubeadmConfigPatchesJSON6902 are applied to the generated kubeadm config
	// as JSON 6902 patches. The `kind` field must match the target object, and
	// if group or version are specified it will only be objects matching the
	// apiVersion: group+"/"+version
	//
	// Name and Namespace are now ignored, but the fields continue to exist for
	// backwards compatibility of parsing the config. The name of the generated
	// config was/is always fixed as is the namespace so these fields have
	// always been a no-op.
	//
	// https://tools.ietf.org/html/rfc6902
	//
	// The cluster-level patches are appied before the node-level patches.
	kubeadmConfigPatchesJSON6902?: [...#PatchJSON6902] @go(KubeadmConfigPatchesJSON6902,[]PatchJSON6902)

	// ContainerdConfigPatches are applied to every node's containerd config
	// in the order listed.
	// These should be toml stringsto be applied as merge patches
	containerdConfigPatches?: [...string] @go(ContainerdConfigPatches,[]string)

	// ContainerdConfigPatchesJSON6902 are applied to every node's containerd config
	// in the order listed.
	// These should be YAML or JSON formatting RFC 6902 JSON patches
	containerdConfigPatchesJSON6902?: [...string] @go(ContainerdConfigPatchesJSON6902,[]string)
}

// TypeMeta partially copies apimachinery/pkg/apis/meta/v1.TypeMeta
// No need for a direct dependence; the fields are stable.
#TypeMeta: {
	kind?:       string @go(Kind)
	apiVersion?: string @go(APIVersion)
}

// Node contains settings for a node in the `kind` Cluster.
// A node in kind config represent a container that will be provisioned with all the components
// required for the assigned role in the Kubernetes cluster
#Node: {
	// Role defines the role of the node in the in the Kubernetes cluster
	// created by kind
	//
	// Defaults to "control-plane"
	role?: #NodeRole @go(Role)

	// Image is the node image to use when creating this node
	// If unset a default image will be used, see defaults.Image
	image?: string @go(Image)

	// TODO: cri-like types should be inline instead
	// ExtraMounts describes additional mount points for the node container
	// These may be used to bind a hostPath
	extraMounts?: [...#Mount] @go(ExtraMounts,[]Mount)

	// ExtraPortMappings describes additional port mappings for the node container
	// binded to a host Port
	extraPortMappings?: [...#PortMapping] @go(ExtraPortMappings,[]PortMapping)

	// KubeadmConfigPatches are applied to the generated kubeadm config as
	// merge patches. The `kind` field must match the target object, and
	// if `apiVersion` is specified it will only be applied to matching objects.
	//
	// This should be an inline yaml blob-string
	//
	// https://tools.ietf.org/html/rfc7386
	//
	// The node-level patches will be applied after the cluster-level patches
	// have been applied. (See Cluster.KubeadmConfigPatches)
	kubeadmConfigPatches?: [...string] @go(KubeadmConfigPatches,[]string)

	// KubeadmConfigPatchesJSON6902 are applied to the generated kubeadm config
	// as JSON 6902 patches. The `kind` field must match the target object, and
	// if group or version are specified it will only be objects matching the
	// apiVersion: group+"/"+version
	//
	// Name and Namespace are now ignored, but the fields continue to exist for
	// backwards compatibility of parsing the config. The name of the generated
	// config was/is always fixed as is the namespace so these fields have
	// always been a no-op.
	//
	// https://tools.ietf.org/html/rfc6902
	//
	// The node-level patches will be applied after the cluster-level patches
	// have been applied. (See Cluster.KubeadmConfigPatchesJSON6902)
	kubeadmConfigPatchesJSON6902?: [...#PatchJSON6902] @go(KubeadmConfigPatchesJSON6902,[]PatchJSON6902)
}

// NodeRole defines possible role for nodes in a Kubernetes cluster managed by `kind`
#NodeRole: string // #enumNodeRole

#enumNodeRole:
	#ControlPlaneRole |
	#WorkerRole

// ControlPlaneRole identifies a node that hosts a Kubernetes control-plane.
// NOTE: in single node clusters, control-plane nodes act also as a worker
// nodes, in which case the taint will be removed. see:
// https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#control-plane-node-isolation
#ControlPlaneRole: #NodeRole & "control-plane"

// WorkerRole identifies a node that hosts a Kubernetes worker
#WorkerRole: #NodeRole & "worker"

// Networking contains cluster wide network settings
#Networking: {
	// IPFamily is the network cluster model, currently it can be ipv4 or ipv6
	ipFamily?: #ClusterIPFamily @go(IPFamily)

	// APIServerPort is the listen port on the host for the Kubernetes API Server
	// Defaults to a random port on the host obtained by kind
	//
	// NOTE: if you set the special value of `-1` then the node backend
	// (docker, podman...) will be left to pick the port instead.
	// This is potentially useful for remote hosts, BUT it means when the container
	// is restarted it will be randomized. Leave this unset to allow kind to pick it.
	apiServerPort?: int32 @go(APIServerPort)

	// APIServerAddress is the listen address on the host for the Kubernetes
	// API Server. This should be an IP address.
	//
	// Defaults to 127.0.0.1
	apiServerAddress?: string @go(APIServerAddress)

	// PodSubnet is the CIDR used for pod IPs
	// kind will select a default if unspecified
	podSubnet?: string @go(PodSubnet)

	// ServiceSubnet is the CIDR used for services VIPs
	// kind will select a default if unspecified for IPv6
	serviceSubnet?: string @go(ServiceSubnet)

	// If DisableDefaultCNI is true, kind will not install the default CNI setup.
	// Instead the user should install their own CNI after creating the cluster.
	disableDefaultCNI?: bool @go(DisableDefaultCNI)

	// KubeProxyMode defines if kube-proxy should operate in iptables or ipvs mode
	// Defaults to 'iptables' mode
	kubeProxyMode?: #ProxyMode @go(KubeProxyMode)
}

// ClusterIPFamily defines cluster network IP family
#ClusterIPFamily: string // #enumClusterIPFamily

#enumClusterIPFamily:
	#IPv4Family |
	#IPv6Family

// IPv4Family sets ClusterIPFamily to ipv4
#IPv4Family: #ClusterIPFamily & "ipv4"

// IPv6Family sets ClusterIPFamily to ipv6
#IPv6Family: #ClusterIPFamily & "ipv6"

// ProxyMode defines a proxy mode for kube-proxy
#ProxyMode: string // #enumProxyMode

#enumProxyMode:
	#IPTablesMode |
	#IPVSMode

// IPTablesMode sets ProxyMode to iptables
#IPTablesMode: #ProxyMode & "iptables"

// IPVSMode sets ProxyMode to iptables
#IPVSMode: #ProxyMode & "ipvs"

// PatchJSON6902 represents an inline kustomize json 6902 patch
// https://tools.ietf.org/html/rfc6902
#PatchJSON6902: {
	// these fields specify the patch target resource
	group:   string @go(Group)
	version: string @go(Version)
	kind:    string @go(Kind)

	// Patch should contain the contents of the json patch as a string
	patch: string @go(Patch)
}

// Mount specifies a host volume to mount into a container.
// This is a close copy of the upstream cri Mount type
// see: k8s.io/kubernetes/pkg/kubelet/apis/cri/runtime/v1alpha2
// It additionally serializes the "propagation" field with the string enum
// names on disk as opposed to the int32 values, and the serlialzed field names
// have been made closer to core/v1 VolumeMount field names
// In yaml this looks like:
//  containerPath: /foo
//  hostPath: /bar
//  readOnly: true
//  selinuxRelabel: false
//  propagation: None
// Propagation may be one of: None, HostToContainer, Bidirectional
#Mount: {
	// Path of the mount within the container.
	containerPath?: string @go(ContainerPath)

	// Path of the mount on the host. If the hostPath doesn't exist, then runtimes
	// should report error. If the hostpath is a symbolic link, runtimes should
	// follow the symlink and mount the real destination to container.
	hostPath?: string @go(HostPath)

	// If set, the mount is read-only.
	readOnly?: bool @go(Readonly)

	// If set, the mount needs SELinux relabeling.
	selinuxRelabel?: bool @go(SelinuxRelabel)

	// Requested propagation mode.
	propagation?: #MountPropagation @go(Propagation)
}

// PortMapping specifies a host port mapped into a container port.
// In yaml this looks like:
//  containerPort: 80
//  hostPort: 8000
//  listenAddress: 127.0.0.1
//  protocol: TCP
#PortMapping: {
	// Port within the container.
	containerPort?: int32 @go(ContainerPort)

	// Port on the host.
	//
	// If unset, a random port will be selected.
	//
	// NOTE: if you set the special value of `-1` then the node backend
	// (docker, podman...) will be left to pick the port instead.
	// This is potentially useful for remote hosts, BUT it means when the container
	// is restarted it will be randomized. Leave this unset to allow kind to pick it.
	hostPort?: int32 @go(HostPort)

	// TODO: add protocol (tcp/udp) and port-ranges
	listenAddress?: string @go(ListenAddress)

	// Protocol (TCP/UDP)
	protocol?: #PortMappingProtocol @go(Protocol)
}

// MountPropagation represents an "enum" for mount propagation options,
// see also Mount.
#MountPropagation: string // #enumMountPropagation

#enumMountPropagation:
	#MountPropagationNone |
	#MountPropagationHostToContainer |
	#MountPropagationBidirectional

// MountPropagationNone specifies that no mount propagation
// ("private" in Linux terminology).
#MountPropagationNone: #MountPropagation & "None"

// MountPropagationHostToContainer specifies that mounts get propagated
// from the host to the container ("rslave" in Linux).
#MountPropagationHostToContainer: #MountPropagation & "HostToContainer"

// MountPropagationBidirectional specifies that mounts get propagated from
// the host to the container and from the container to the host
// ("rshared" in Linux).
#MountPropagationBidirectional: #MountPropagation & "Bidirectional"

// PortMappingProtocol represents an "enum" for port mapping protocol options,
// see also PortMapping.
#PortMappingProtocol: string // #enumPortMappingProtocol

#enumPortMappingProtocol:
	#PortMappingProtocolTCP |
	#PortMappingProtocolUDP |
	#PortMappingProtocolSCTP

// PortMappingProtocolTCP specifies TCP protocol
#PortMappingProtocolTCP: #PortMappingProtocol & "TCP"

// PortMappingProtocolUDP specifies UDP protocol
#PortMappingProtocolUDP: #PortMappingProtocol & "UDP"

// PortMappingProtocolSCTP specifies SCTP protocol
#PortMappingProtocolSCTP: #PortMappingProtocol & "SCTP"
